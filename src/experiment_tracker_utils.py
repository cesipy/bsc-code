import experiment_tracker


def print_summary(training_results: dict):
    """Print a summary of training results, generated by genai"""
    print("\n" + "-"*60)
    print("training summary")
    print("-"*60)

    config = training_results.get("config", {})
    print(f"\nConfiguration:")
    print(f"\tcoattn layers (text):   {config.get('t_biattention_ids', [])}")
    print(f"\tcoattn layers (vision): {config.get('v_biattention_ids', [])}")
    print(f"\tlr {config.get('learning_rate', 'N/A'):.2e}")
    print(f"\tepochs: {config.get('epochs', 'N/A')}")
    print(f"\tseed: {config.get('seed', 'N/A')}")
    print(f"\tcontr. loss: {config.get('use_contrastive_loss', False)}")

    for task in ["hateful_memes", "mm_imdb"]:

        training = training_results[task].get("training", {})
        first_epoch_data = training.get(1, training.get("1", {}))


        if first_epoch_data == {}:
            continue
        if task not in training_results:
            continue

        print(f"\n{task}:")
        training = training_results[task].get("training", {})

        if not training:
            print("  No training data ")
            continue

        epochs = sorted([k for k in training.keys() if isinstance(k, int)])

        if epochs:
            last_epoch = epochs[-1]
            last_metrics = training[last_epoch]
            best_val_acc = max([training[e].get("val_acc", 0) for e in epochs])
            best_val_loss = min([training[e].get("val_loss", float('inf')) for e in epochs])

            print(f"\tfinal epoch ({last_epoch}):")
            print(f"\t\ttrain loss: {last_metrics.get('train_loss', 'N/A'):.4f}")
            print(f"\t\tval loss:   {last_metrics.get('val_loss', 'N/A'):.4f}")
            print(f"\t\tval acc:    {last_metrics.get('val_acc', 'N/A'):.4f}")
            print(f"\tbest across all epochs:")
            print(f"\t\tbest val acc:  {best_val_acc:.4f}")
            print(f"\t\tbest val loss: {best_val_loss:.4f}")

            alignment_data = training_results[task].get("alignment", {})
            # TODO alignment, bit first needs to be fixed for new arch
            if alignment_data[1] == {}:
                continue

            print(alignment_data)
            alignment= alignment_data
            alignment_epochs = []
            for k in alignment.keys():
                if isinstance(k, int):
                    alignment_epochs.append(k)
                elif isinstance(k, str) and k.isdigit():
                    alignment_epochs.append(int(k))

            if alignment_epochs:

                last_align_epoch = max(alignment_epochs)
                last_align_data = alignment.get(last_align_epoch, alignment.get(str(last_align_epoch), {}))

                if last_align_data:
                    print(f"\talignment metrics (epoch {last_align_epoch}):")

                    metrics_to_show = ['cka', 'cosine', 'procrustes_full_epoch']

                    for metric in metrics_to_show:
                        values = []
                        for layer_key, layer_data in last_align_data.items():
                            if isinstance(layer_data, dict) and metric in layer_data:
                                values.append(layer_data[metric])

                        if values:
                            avg_val = sum(values) / len(values)
                            print(f"\t\tavg {metric}: {avg_val:.4f}")

    print("-"*60 + "\n")
